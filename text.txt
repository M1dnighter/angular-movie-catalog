1. Распространение события - это движение события от корневого элемента к целевому и обратно
 - по сути, прохождение всех трёх фаз. Когда мы кликаем по кнопке, событие происходит не только
  на кнопке, а на всех его родительских элементах. Кнопка, в данной случае, является целевым элементом.

  Фаза погружения (capturing) - событие идёт сверху вниз т.е движется по дереву DOM от корневого к целевому элементу.

  Фаза всплытия (bubbling) - событие наоборот поднимается вверх по дереву DOM от целевого элемента к корневому.

  Фаза цели (target) - События будут двигаться от корневого к целевому и обратно. По умолчанию все события 
    будут ловиться на фазе всплытия, но по требованию событие можно отловить и на фазе погружения.

  Нажатие на кнопку, которая находится в контейнере. Когда пользователь нажимает на кнопку, событие щелчка 
  распространяется от кнопки к контейнеру, так как кнопка находится в контейнере.
  или
  Клик по внутреннему элементу. Всплытие гарантирует, что клик по внутреннему элементу вызовет обработчик
  onclick (если есть) сначала на самом элементе, затем на его родителе, затем выше и так далее, вверх по цепочке вложенности.

2. Объект Promise используется для отложенных и асинхронных вычислений.
  Он позволяет обрабатывать результаты асинхронных операций так, 
  как если бы они были синхронными: вместо конечного результата асинхронного метода 
  возвращается "Обещание" получить результат в некоторый момент в будущем.

  Promise может находиться в трёх состояниях: 
    ожидание (pending): начальное состояние, не исполнен и не отклонён.
    исполнено (fulfilled): операция завершена успешно.
    отклонено (rejected): операция завершена с ошибкой.
  При создании промис находится в ожидании (pending), а затем может стать исполненным (fulfilled), 
  вернув полученный результат (значение), или отклонённым (rejected), вернув причину отказа.

  Callbacks - Асинхронная функция принимает функцию обратного вызова, которая будет вызвана после завершения операции.

  async/await - синтаксический сахар над промисами в JavaScript, который позволяет писать асинхронный код, выглядящий как синхронный. 
  На деле всё работает на тех же промисах, но код выглядит чище и читается легче. 

  Event Loop решает, когда и в каком порядке выполняются асинхронные операции. Он делит все задачи на подтипы:

    Макрозадачи - все асинхронные операции, такие как setInterval, setTimeout и т.д.

    Микрозадачи - (Promise.then, async/await) выполняются перед макрозадачами.

    Задачи отрисовки - задачи связанные с отрисовкой и обновлением контента страницы.

3. ООП - Парадигма разработки прогаммного обеспечения в котором система представляется как совокупность взаимодействующих объектов друг с другом.
  Объекты - это сущности у которых есть данные о себе и методы работы с этими данными. Для того чтобы создать объект 
  используют шаблон - Класс, объекты являются экземплярами класса. Грубо говоря объекты это то, что находится в памяти программы,
  а классы это правила по которым эти объекты создаются и какими возможностями наделяются. У каждого класса есть конструктор -
  функция которая отвечает за создание класса или объекта, поля - данные которые связанные с конкретным объектом, методы - 
  функции которые может выполнять объект, аксессоры - геттеры и сеттеры задачи которых контралировать доступ к полям класса.

  Используя ООП следует помнить про ключевые парадигмы:
    Инкапсуляция - контроль доступа к полям и методам объекта. Под контролем доступа подразумевается не только можно/нельзя обратится,
    но и различные валидации подгрузки, вычисления и прочее динамические поведения.

    Пример:
    class Car {
        public name: string;
        private _number: string;

        private compare() {
            return this._number + this.name;
        }
    }

    let car1 = new Car();
    car1._number        //извне к полю _number обратится нельзя, все манипуляции с ним доступны только внутри класса

    Нследование - механизм системы, который позваляет наследовать одними классами свойства и поведения других классов для дальнейшего
    расширения или модификации.

    Пример:
    class ClassBase {
        public property1: number;
        protected property2: string;
        private _property3: boolean;

        constructor(p1: number, p2: string, p3: boolean) {
            this.property1 = p1;
            this.property2 = p2;
            this._property3 = p3;
        }

        /* Получить информацию о полях */
        public getInfo(): string {
            return `property1=${this.property1} property2=${this.property2} property3=${this._property3}`;
        }
    }

    class ClassA extends ClassBase {
        constructor() {
            super(1, "Экземпляр класса A", true);
        }
    }

    class ClassB extends ClassBase {
        constructor() {
            super(2, "Экземпляр класса B", false);
        }
    }

    class ClassC extends ClassBase {
        constructor() {
            super(3, "Экземпляр класса C", true);
        }
    }

    let classA = new ClassA();
    console.log(classA.getInfo());
    let classB = new ClassB();
    console.log(classB.getInfo());
    let classC = new ClassC();
    console.log(classC.getInfo());


    Полиморфизм - свойство системы позволяющее иметь множество реализаций одного интерфейса, проще говоря это возможность класса-наследника
    корректировать реализацию метода класса родителя.

    Пример:
    interface ILogger {
        log(message: string): void;
    }

    class ConsoleLogger implements ILogger {
        log(message: string): void {
            console.log("Console:", message);
        }
    }

    class FileLogger implements ILogger {
        log(message: string): void {
            console.log("File:", message);
        }
    }

    function writeLog(logger: ILogger) {
        logger.log("Hello");
    }

    writeLog(new ConsoleLogger());
    writeLog(new FileLogger());


    Абстракция - предание объекту характеристик, которые отличают его от других объектов четко определяя его концкптуальные границы.

    Пример:
    abstract class Animal {
        abstract makeSound(): void; // абстрактный метод

        move(): void {
            console.log("Животное движется");
        }
    }

    class Dog extends Animal {
        makeSound(): void {
            console.log("Гав");
        }
    }

    class Cat extends Animal {
        makeSound(): void {
            console.log("Мяу");
        }
    }

    const dog = new Dog();
    dog.makeSound(); // Гав
    dog.move();      // Животное движется

  
  В JavaScript ООП реализовано на основе прототипной модели наследования.
  Каждый объект имеет скрытое свойство [[Prototype]], через которое он может наследовать методы и свойства других объектов.
  Для удобства разработки в JavaScript используется синтаксис class, который является синтаксическим сахаром над прототипной моделью 
  и позволяет описывать классы, конструкторы, наследование (extends), вызов родительского конструктора (super), 
  а также геттеры и сеттеры в привычной объектно-ориентированной форме.

4. Когда пользователь вводит URL в адресную строку, браузер сначала парсит его и определяет протокол, домен и путь. 
  Затем он выполняет DNS-резолвинг, чтобы получить IP-адрес сервера сначала проверяет кэш браузера и ОС, потом DNS-серверы.
  После получения IP браузер устанавливает сетевое соединение: выполняется TCP-handshake, а если используется HTTPS дополнительно
  TLS-handshake с проверкой сертификата.
  Затем браузер отправляет HTTP-запрос серверу. Сервер обрабатывает запрос и возвращает HTTP-ответ с HTML-документом и связанными ресурсами.
  Браузер начинает парсить HTML, строит DOM-дерево, параллельно загружает CSS и формирует CSSOM. На основе DOM и CSSOM строится 
  render tree, после чего выполняется layout (расчёт размеров и позиций элементов), и затем paint (отрисовка пикселей на экране).
  JavaScript может модифицировать DOM и вызывать повторный layout и repaint.
  Процесс ускоряется за счёт кэширования, CDN, сжатия данных (gzip, brotli), использования HTTP/2 или HTTP/3, а также preload, prefetch и 
  Service Worker.
  В процессе могут возникать проблемы безопасности: XSS-атаки, CSRF, подмена сертификатов, а также ограничения междоменного 
  взаимодействия из-за политики Same Origin и механизма CORS.

